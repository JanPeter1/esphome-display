text_sensor:
  - platform: homeassistant
    id: katzenklo_dienst
    name: Katzenklodienst
    entity_id: sensor.katzenklo_dienst
    on_value:
      then:
        - lvgl.label.update:
            id: label_message_1
            text:
              format: "%s"
              args: [ 'x.c_str()' ]

  - platform: homeassistant
    id: calendar_events
    entity_id: sensor.calendar_events
    on_value:
      then:
        - lambda: |-
            std::vector<std::string> events;
            std::string text = x;
            int cnt = 0;
            int offset = 0;  // offset for 2x time plus one "T"
            int offset1 = 0; // offset for 1x time
            char date[25];
            struct tm start_time;
            struct tm end_time;
            time_t current = ::time(NULL);
            struct tm *current_time = localtime(&current);
            int pos = text.find('#');
            static std::vector<lv_obj_t *> levents     =  { messages_t1, messages_t2, messages_t3, messages_t4, messages_t5, messages_t6, messages_t7 };
            static std::vector<lv_obj_t *> leventicons =  { messages_i1, messages_i2, messages_i3, messages_i4, messages_i5, messages_i6, messages_i7 };
            static const char *dayOfWeek[] = { "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" };
            while ((pos != std::string::npos) && (pos < text.length())) {
              events.push_back(text.substr(0, pos));
              text = text.substr(pos+1);
              text.erase(0, text.find_first_not_of(" \n\r\t"));
              pos = text.find('#');
            }
            std::sort(events.begin(), events.end());
            for (int cnt = 0; cnt < std::min(levents.size(), events.size()); cnt++)
            {
              text = events[cnt];
              ESP_LOGD("messages", text.c_str());

              if (text[10] == 'T') {
                // date + time
                offset = 30;
                if (strptime(text.substr(0, 19).c_str(), "%FT%T", &start_time) == NULL) { ESP_LOGD("messages", "error parsing start time"); continue; };
                if (strptime(text.substr(26, 19).c_str(), "%FT%T", &end_time) == NULL)  { ESP_LOGD("messages", "error parsing end time"); continue; };
              } else {
                if (strptime(text.substr(0, 10).c_str(), "%F", &start_time) == NULL) { ESP_LOGD("messages", "error parsing start date"); continue; };
                if (strptime(text.substr(11, 10).c_str(), "%F", &end_time) == NULL) { ESP_LOGD("messages", "error parsing end date"); continue; };
              }
              time_t t1 = mktime(&start_time);
              time_t t2 = mktime(&end_time);
              double diffSecs = difftime(t2, t1);

              snprintf(date, 25, "%d", int(diffSecs));
              ESP_LOGD("messages", date);

              bool today = false;
              bool tomorrow = false;
              if ((start_time.tm_mday == current_time->tm_mday) && (start_time.tm_mon == current_time->tm_mon) && (start_time.tm_year == current_time->tm_year)) {
                today = true;
              } else if (((start_time.tm_mday == current_time->tm_mday+1) && (start_time.tm_mon == current_time->tm_mon)   && (start_time.tm_year == current_time->tm_year)) ||
                         ((start_time.tm_mday == 1)                       && (start_time.tm_mon == current_time->tm_mon+1) && (start_time.tm_year == current_time->tm_year)) ||
                         ((start_time.tm_mday == 1)                       && (start_time.tm_mon == 1)                      && (start_time.tm_year == current_time->tm_year+1))) {
                tomorrow = true;
              }

              if ((diffSecs == 60*60*24) || (diffSecs == 60*60*24 - 1) || (diffSecs == 60*60*24 - 1 - 60*60)) {
                // exactly one day
                if (today) {
                  snprintf(date, 25, "Heute");
                } else if (tomorrow) {
                  snprintf(date, 25, "Morgen");
                } else {
                  snprintf(date, 25, "%s %02D.%02D.", dayOfWeek[start_time.tm_wday], start_time.tm_mday, start_time.tm_mon+1);
                }
              } else if (diffSecs > 60*60*24) {
                // more than one day
                snprintf(date, 25, "%02D.%02D. - %02D.%02D", start_time.tm_mday, start_time.tm_mon+1, end_time.tm_mday, end_time.tm_mon+1);
              } else {
                // less that one day
                if (today) {
                  snprintf(date, 25, "Heute %02D:%02D-%02D:%02D", start_time.tm_hour, start_time.tm_min, end_time.tm_hour, end_time.tm_min);
                } else if (tomorrow) {
                  snprintf(date, 25, "Morgen %02D:%02D-%02D:%02D", start_time.tm_hour, start_time.tm_min, end_time.tm_hour, end_time.tm_min);
                } else {
                  snprintf(date, 25, "%s %02D.%02D. %02D:%02D-%02D:%02D", dayOfWeek[start_time.tm_wday], start_time.tm_mday, start_time.tm_mon+1, 
                                      start_time.tm_hour, start_time.tm_min, end_time.tm_hour, end_time.tm_min);
                }
              }
              // 2025-01-08T10:45:00+01:00 2025-01-08T12:00:00+01:00 󰭦 Arzt
              // 2025-01-07 2025-01-11 󱫿 Langer Termin

              //ESP_LOGD("messages", date);
              if (text.length() < 29 + offset) continue;
              lv_label_set_text(leventicons[cnt], text.substr(22 + offset, 4).c_str());
              lv_label_set_text(levents[cnt],     (std::string(date) + " " + text.substr(27 + offset, text.length() - 27 - offset)).c_str());
              ESP_LOGD("messages", (std::string(date) + " " + text.substr(27 + offset, text.length() - 27 - offset)).c_str());
            }

